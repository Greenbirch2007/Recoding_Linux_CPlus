

windows 会产生一个a.exe的可执行文件

unix编译器会产生一个a.out的文件

在unix系统中，即使在当前目录，有时也必须指定文件所在的目录

"." 后面的斜杠表明文件处于当前目录下

让问main函数的返回值的方式和系统有关


查看所用的编译器文档，了解它所用的文件命名规范


修改程序使其返回-1.返回值-1通常作为程序运行失败的指示器


1.2  初探输入、输出


c++并没有直接定义进行输入或输出(IO)的任何语句，这种功能功能由标准哭提供的。
IO标准库提供了大量的shezhi
大部分例子处理格式化输入和输出的iostream库

iostream库的基础是两种命名为istream和ostream的类型，分别表示输入流和输出流

流是指要从某种IO设备上读入或写出的字符序列。
流师徒说明字符是随着时间顺序生成或消耗的


1.2.1  标准输入与输出对象

标准库定义了4个IO对象

1. 处理输入时实用命名为cin（读作see-in）的istream类型对象。这个对象也称为标准输入
2.处理输出时使用命名为cout(读作see-out)的ostream类型对象，这个对象也称为标准输出
3. 标准错误，cerr(读作see-err)，通常用来输出警告和错误信息给程序的使用者
4.clog(读作see-log)，clog对象用于产生程序执行的一般信息


一般情况下，系统将这些对象与执行程序的窗口联系起来
当我们从cin读入时，数据从执行程序的窗口读入，当写到cin,cerr或clog时，输出
写至同一窗口。
运行程序时，大部分操作系统都提供了重定向输入或输出流的方法。利用重定向可以将这些流与所
选择的文件联系起来

1.2.2  一个实用IO库的程序

#include <iostream>

告诉编译器要使用iostream库。尖括号的名字是一个。头文件，
程序实用库工具时必须包含相关的头文件。
#include指示必须单独写成一行----头文件名和#include必须在同一行。

通常，#include指示应出现在任何函数的外部。习惯上，程序的所有#include指示都在文件开头部分出现


写入到流


main函数体中第一条语句执行了一个表达式。
c++中，一个表达式由一个或几个操作数和通常是一个操作符组成。该语句的表达式使用输出操作符(<< 操作符)
在标准输出上输出提示语：

std:: cout << "Enter two numbers:" << std::endl;

这个语句用了两次输出操作符。每个输出操作符实例都接受两个操作数：
左操作数必须是ostream对象；右操作数是要输出的值。
操作符将其右操作数写到作为其左操作数的ostream对象


c++中，每个表达式都会产生一个结果，通常是将操作符作用到其操作数产生的值。
当操作符是输出操作符时，结果是左操作数的值。输出操作返回的值是输出流本身

既然输出操作符返回的是其左操作数，那么我们就可以将输出请求链接在一起


endl是一个特殊值，成为操纵符，将它写入输出流时，具有输出换行的效果，并刷新与设备相关联的缓冲区。
通过刷新缓冲区，用户可立即看到写入到流中的输出


程序员经常在调试过程中插入输出语句，这些语句都应该刷新输出流。
忘记刷新输出流可能会造成输出流停留在缓冲区中，如果程序崩溃，将会导致程序错误推断崩溃的位置



使用标准库中的名字


std::cout   std::endl

前缀std::表明cout和endl是定义在命名空间std中的。使用命名空间程序员可以避免与库中定义的名字
相同而引起冲突

因为标准库定义的名字是定义在命名空间中，所以我们可以按自己的意图实用相同的名字




标准库使用命名空间的副作用是，当我们实用标准库中的名字时，必须显式地表达出使用的是命名空间std下的
名字。std::cout的写法使用了作用域操作符(::操作符)，表示实用的是定义在命名空间std中的cout

读入流

p24

在输出提示语后，将读入用户输入的数据。先定义两个名为v1和v2的变量来保存输入：

int v1,v2;

将这些变量定义为int类型，int类型是一种代表整数值的内置类型。这些变量为初始化，表示没有赋给
他们初始值。这些变量在首次时候时会读入一个值，因此没有初始值

下一条语句读取输入：

std:: cin >> v1 >> v2;

输入操作符  (>> 操作符) 行为与输出操作符相似。它接受一个istream对象作为其左操作符数，
接受一个对象作为其右操作数，它从istream操作数读取数据病保存到右操作数中。想输出操作符一样，
输入操作符返回其左操作数作为结果。由于输入操作符返回其左操作数，我们可以将输入请求
序列合并成单个语句。 这个输入操作等价于：

std:: cin>> v1;
std:: cin>> v2;


输入操作的效果是从标准输入读取两个值，将第一个存放在v1中，第二个存放在v2中。


完成程序

它将每个操作数输出到标准输出。有趣的是操作数并不都是同一类型的值，有些操作数是字符串字面值

"the sum of"

其他是各种int值， 如v1,v2以及对算数表达式 v1+v2

求值的结果。iostream库定义了接受全部内置类型的输入输出操作符版本


在写c++程序时，大部分出现空格符的地方可用换行符替代。这条规则的一个例外是字符串字面值中的空格
符不能用换行字符代替。
另一个例外是空格符不允许出现在预处理提示中。

关键概念： 已初始化变量和未初始化变量


在c++中，有初始化的概念


已初始化变量是指变量在定义时就给定一个值。未初始化变量则未给定初始值


int val1 = 0;
int val2 ;



定义变量时，应该给变量赋初始值，除非确定将变量用于其他意图之前会覆盖这个初值。如果
不能保证读取变量之前重置变量，就应该初始化变量。。



1.3 关于注释 


注释可以帮助其他人阅读程序，通常用于括号算法，确认变量的用途或阐明难以理解的代码段。


c++中有单行注释和成对注释两种类型的注释。 单行注释一双斜线(//)开头，行中
处于双斜线右边的内容是注释，被编译器忽略

还可以用d定界符/**/

任何允许有制表符，空格或换行符的地方都允许放注释对。


注释对不可嵌套

1.4 控制结构

1.4.1  while语句

while语句提供了迭代执行功能。可以用while语句编写一个1到10求和的程序

块是被花括号括起来的语句序列。c++中，块可用于任何可以用于一条语句的地方。


1.4.2  for语句

在while循环中，我们使用变量val来控制循环执行次数。每次执行while语句，
都要测试val的值。

在for循环之前，我们定义sum并赋0值.用于迭代的变量val被定义为for语句自身的一部分

包含for语句头和语句体两部分。for语句头控制for语句体的执行次数。for语句头由三部分组成：
一个初始化语句，一个条件，一个表达式。

在标准化之前的c++中，定义在for语句头的名字在for循环外是可访问的。


再谈编译

编译器的部分工作是寻找程序代码中的错误。编译器不能查出程序的意义是否正确，
但它可以查出程序形式上的错误

1.语法错误
2.类型错误。c++中每个数据项都有其相关联的类型。如，值10是一个整数。用双引号标
起来的单词"hello" 是字符串字面值。
类型错误的一个实例是传递了字符串字面值个应该得到整型参数的函数

2.声明错误。c++程序中实用的每个名字必须在使用之前声明。没有声明名字通常会导致错误信息。

最常见的两种声明错误，是从标准库中访问名字时忘记使用"std::",以及由于疏忽而拼错标识符名


1.4.3 if语句

1.4.4 读入未知数目的输入

还可以允许用户指定一组数求和。这种情况下，我们不知道要对多少个数求和，而是要一直
读数直到程序输入结束。输入结束时，程序将总和写到标准输出

从键盘输入文件结束符

操作系统实用不同的值作为文件结束符。

windows 以 ctrl + z 来输入文件结束符

unix系统中，包括max ,通常实用ctrl + d

1.5 类的简介


c++中我们通过定义类来定义自己的数据结构。
类机制是c++中最重要的特征之一。c++设计的主要焦点就是使
所定义的类类型的行为可以想内置类型一样自然。

使用类时我们需要回答三个问题：

1.类的名字是什么？
2.它在哪里定义？
3.它支持什么操作

对于书店问题，我们假定类命名为Sales_item 且类定义在命名为Sales_item.h的头文件中


1.5.1 Sales_item类

我们需要知道这个类提供什么操作

像IO一样的库工具，必须包含相关的头文件。
对于自定义的类，必须使得编译器可以访问和类相关的定义。
一般来说，我们将类定义放入一个文件中，要使用该类的任何程序都必须包含这个文件


依据惯例，类类型存储在一个文件中，其文件名如同程序的源文件名一样
由文件名和文件后缀两部分组成。通常文件名和定义在头文件中的类名是一样的
通常后缀是.h,

假定我们的类定义在名为Sales_item.h 的文件中


Sales_item对象上的操作


每个类定义一种类型，类型名与类名相同。

我们的Sales_item类定义了一种命名为Sales_item的类型。像实用内置类型一样，可以定义
类类型的变量

Sales_item item;
就表示item是类型 Sales_item的一个对象。

除了可以定义Sales_item类型的变量，我们还可以执行Sales_item对象的以下操作：

加法操作符，+，将两个Sales_item相加
输入操作符，<< ,来读取一个Sales_item对象
输出操作符，>>,来输出一个Sales_item对象
赋值操作符，=，将一个Sales_item对象赋值给另一个Sales_item对象
调用same_isbn函数确定两个Sales_item是否是同一本书


读入和写出 Sales_item对象

下面一个程序，从标准输入读取数据，使用该数据建立一个Sales_item对象，
并将该Sales_item对象写到标准输出

iosream头文件由标准库定义，而Sales_item头文件则不是。Sales_item是一种
自定义类型。当使用自定义头文件时，使用“”把头文件名括起来


标准库的头文件用<>括起来，非标准库的头文件用双引号“”括起来

在main函数中，首先定义一个对象，命名为book,用它保存从标准输入读取的数据。
下一条语句读入数据到此对象，第三条语句将它打印到标准输出，
像平常一样紧接着打印endl来刷新缓冲区

类定义行为
1.5.2 初探成员函数

调用命名为item1的Sales_item对象的成员函数，成员函数是由类定义的函数，也称为类方法

成员函数只另一一次，但被视为每个对象的成员。我们将这些操作称为成员函数，是因为它们（通常）在特定对象上操作。

在这个意义上，它们是对象的成员，即使同一类型的所有对象共享同一个定义也是如此

当调用成员函数时，指向函数要操作的对象。使用点操作符(.)

点操作符通过它的左操作数取得右操作数。
点操作符仅用于类类型的对象：左操作必须是类类型的对象，右操作必须指定该类型的成员


点操作符的右操作数不是对象或值，而是成员的名字

通常使用成员函数作为点操作符的右操作数来调用成员函数。执行成员函数和执行其他函数类似：要调用函数，可将调用操作符()
放在函数名之后，调用操作符是一对圆括号，括住传递给函数的实参列表(可能为空)


1.6  c++程序

头文件如何写？

第一部分 基本语言


内置数据类型：如整型，字符型
表达式和语句：表达式和语句用于操纵上述类型的值
变量：程序员可以使用变量对所用的对象命名
控制结构：如if或while,程序员可以使用控制结构有条件地执行或重复执行一组动作
函数：程序员可以使用函数把行为抽象成可调用的计算单元

大多数程序语言采用两种方式对上面的基本特征集进行扩充：允许程序员通过自定义数据类型扩展该语言；
提供一组库例程，这些例程定义了一些并非内置在语言中的实用函数和数据类型


c++中对象的类型决定了该对象可以执行的操作。语句正确与否取决于该语句中对象的类型。

python在运行时才检查语句中对象的类型。相反，c++是静态类型语言，在编译时执行类型检查。
结果是程序中使用某个名字之前，必须先告知编译器该名字的类型

c++中最重要的特征是类(class),程序员可以使用类自定义数据类型，成为类类型(class type),以区别语言的内置类型

掌握c++的第一步是学习语言的基本知识和标准库
第二章，探讨内置数据类型，以及自定义新类型的机制
第三章，引入两种最基本的标准库类型：string,vector
第四章，介绍数组，数组是一种低级的数据结构，内置于c++和其他语言，数组类似于vector对象，但较难实用


第二章 变量和基本类型

类型是所有程序的基础。类型告诉我们数据代表什么意思以及可以对数据执行哪些操作


c++定义了几种基本类型：字符型，整型，浮点型等

c++还提供了可用于自定义数据类型的机制，标准库正式利用这些机制定义了更复杂的类型
比如可变长字符串 string,vector等

类型确定了数据和操作在程序中的意义


c++中对类型的支持是非常广泛的：语言本身定义了一组基本类型和修改已有类型的方法，还
提供了一组特征用于自定义类型。


2.1  基本内置类型


c++定义了一组表示整数，浮点数，单个字符和布尔值的算术类型，另外还定义了一种称为void
的特殊类型。void类型没有对应的值，仅用在有限的一些情况下，通常用作无法返回值函数的返回类型


算术类型的存储空间依据机器而定。这里的存储空间是指用来表示该类型的位(bit)数。
c++标准规定了每个算术类型的最小存储空间，但它并不阻止编译器使用更大的存储空间。

事实上，对于int类型，几乎所有的编译器使用的存储空间都比所要求的要大

bool NA
char 8 bits
wchar_t 16 bits
short 16 bits
int 16bits
long 32 bits
float 6 sd
double 10 sd
long double 10 sd

因为位数的不同，这些类型所能表示的最大(最小)值也因机器的不同而不同


2.1.1  整型

表示整数，字符和布尔值的算术类型合称为整形

字符类型有两种：char,wchar_t

char类型保证了有足够的空间，能够存储机器基本字符集中任何字符相应的数值，因此
char类型通常是单个机器字节(byte)

wchar_t 类型用于扩展字符集，比如汉字和日语，这些字符集中的一些字符不嗯给你用单个char表示


short,int,long类型都表示整型值，存储空间的大小不同。

内置类型的机器级表示


c++的内置类型与其在计算机的存储器中的表示方式紧密相关。

计算机以位序列存储数据，每一位存储0或1

让存储具有结构的最基本方法是用块(chunk)处理存储


大多数计算机将存储中的每一个字节和一个称为地址的数关联起来
一旦知道了该地址的值的类型，就知道了表示该类型的值需要多少位
和如何解释这些位

bool类型表示真值true和false.可以将算术类型的任何值赋给bool对象。0值算术类型
代表false,任何非0的值代表true


带符号和无符号类型

除了bool类型外，整型可以是带符号的(signed)也可以是无符号的(unsigned)

带符号类型可以表示正数也可以表示负数(包括0)
而无符号型只能表示大于或等于0的数


整型int,short,long都是默认为带符号型。要获得无符号型则必须指定该类型为unsigned,
比如 unsigned long. 
unsigned int 类型可以简写为unsigned  

unsigned 后面不加其他类型说明意味着是unsigned int


char 有三种不同的类型： plain char,  unsigned char,  signed char


整型值的表示


无符号型中，所有的位都表示数值。定义一种类型使用8位表示，那么这种类型的unsigned型可以取值0到255

c++标准并未定义signed类型如何用位来表示，而是由每个编译器自由决定如何表示signed类型
表示signed整型类型最常见的策略是用其中一个位作为符号位。
符号位为1，值就为负数；符号位为0，值就为0或正数

一个signed整型取值是从-128 到127

整型的赋值

对象的类型决定对象的取值

对于unsigned类型来说，编译器必须调整越界值使其满足要求。编译器会将该值
对unsigned类型的可能取值数目求模，然后取得求值


对于unsigned类型来说，负数总是超出取值范围。unsigned类型的对象可能永远不会保存负数。
c++中，把负值赋值给unsigned对象是完全合法的，其结果是该类型的取值个数求模后的值。

当将超过取值范围的值赋值给signed类型时，由编译器决定实际赋的值


2.1.2  浮点数


类型 float,double,long double


对于实际的程序来说，float类型精度通常是不够的---float型只能保证6位有效数字，
而double型至少可以保证10位有效数字，能满足大多数计算的需要


建议：实用内置算术类型


2.2 字面值常量


整型字面值规则

定义字面值整数常量可以实用一下三种进制的任何一种：十进制，八进制，十六进制

字面值整数常量的类型默认为int或long类型


定义长整型时，应该使用大写字母L。


没有short类型的字面值常量


浮点数字面值规则

通常可以用十进制或科学计数法来表示浮点字面值常量。

默认的浮点字面值常量为double类型

布尔字面值和字符字面值


单词true和false是布尔型的字面值；

bool test = false;

可打印的字符型字面值通常用一对单引号来定义


‘a’  这些字面值都是char类型的。
在字符字面值前加L就能够得到wchar_t 类型的宽字符字面值，如  L‘a’



非打印字符的转义序列


有些字符是不可打印的。不可打印字符实际上是不可显示的字符

不可打印字符和特殊字符都用转义字符书写。转义字符都以反斜线符号开始

换行符  \n
水平制表符  \t
纵向制表符   \v
退格符   \b
回车符   \r
进纸符  \f
报警(响铃)符  \a
反斜线   \\
疑问号   \?
单引号  \'
双引号  \"

我们可以将任何字符表示为一下形式的通用转义字符：   \ooo


字符‘\0’ 通常表示"空字符(null character)",我们将会看到它有非常特殊的意义


字符串字面值


字符串字面值是一串常量字符

字符串字面值常量用双引号括起来的零个或多个字符表示。不可打印字符表示成相应的转义字符

为了兼容C语言，c++中所有的字符串字面值都由编译器自动在末尾添加一个空格字符

宽字符串字面值是一串常量宽字符，同样以一个宽空字符结束


字符串字面值的连接

两个相邻的仅由空格、制表符或换行符分开的字符串字面值(或宽字符串字面值)
可以连接成一个新字符串字面值。


多行字面值

处理长字符串有一个更基本的方法：在一行的末尾加一反斜线符号可将此行和下一行当做同一行处理

注意反斜线符号必须是该行的尾字符----不允许有注释或空格符。

后继行首的任何空格和制表符都是字符串字面值的一部分

长字符串字面值的后继才不会有正常的缩进


建议：不要依赖未定义的行为

2.3  变量

1.使用已命名对象执行运算并输出每次计算
2.使用控制流结构，当某个条件为真时重复执行一系列程序语句



value,pow,result,cnt都是变量，可以对数值进行存储，修改和查询

for循环使得计算过程重复执行pow次


关键概念：强静态类型

c++是一门静态类型语言，在编译时会作类型检查

在c++中，操作是否合法是在编译时检查的

2.3.1  什么是变量

变量提供了程序可以操作的有名字的存储区。c++中的每一个变量都有特定的类型，
该类型决定了变量的内存大小和布局，能够存储与该内存中的值取值范围以及可应用在该变量上的操作集

c++程序员常常吧变量称为"变量"或"对象(object)"


左值和右值

1. 左值，左值可以出现在赋值语句的左边或右边
2. 右值，右值只能出现在赋值的右边，不嗯给你出现在赋值语句的左边


变量是左值，因此可以出现在赋值语句的左边。数字字面值是右值，因此，不能被赋值

有些操作符，比如赋值。要求其中的一个操作数必须是左值。
结果，可以使用左值的上下文比右值更广。左值出现的上下文决定了左值是如何使用的


一般而言，对象就是内存总具有类型的区域。计算左值表达式就会产生对象


2.3.2 变量名

变量名，即变量的标识符，可以由字母，数字和下划线组成。变量名必须以字母或下划线开头，
并且区分大小写字母；c++中的标识符都是大小写敏感的


c++关键字

asm,do,if,return,try,auto,double,inline,short,typedef,
bool,dynamic_cast,int,signed,typeid,break,else,long,sizeof,
typename,case,enum,mutable,static,union,catch,explicit,namespace,
static_cast,unsigned,char,export,new,struct,using,class
extern,operator,switch,virtual,const,false,private,template,
void,const_cast,float,protected,this,volatile,continue,
for,public,throw,wchar_t,default,friend,register,true,while
delete,goto,reinterpret_cast



c++操作符替代名


and bitand ,compl,not_eq,or_eq,xor_eq
end_eq,bitor,not,or,xor

除了关键字，c++标准还保留了一组标识符用于标准库。

标识符不能包含两个连续的下划线，也不能以下划线开头后面紧跟一个大写字母。
有些标识符(在函数外定义的标识符) 不能以下划线开头哦


变量命名习惯

1.变量名一般用小写字母
2.标识符应实用能帮助记忆的名字。能够提示其在程序中的用法的名字
3.包含多个词的标识符书写为在每个词之间添加一个下划线，或每个
内嵌的词的第一个字母都大写，如 student_loan,studentLoan


命名习惯最重要是保持一致



每个定义都是以类型说明符开始，后面紧跟着以逗号分开的含有一个或多个
说明符的列表。分号结束定义。类型说明符指定与对象相关联的类型


内置类型名  int ,double

标准库定义的类型名   std::string

自定义的类型名：  Sales_item


类型决定了分配给变量的存储空间的大小和可以在其上执行的操作

多个变量可以定义在同一条语句中


初始化


变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时指定了初始值的对象
被称为是已初始化的。
c++支持两种初始化变量的形式：复制初始化和直接初始化。

复制初始化语法用等号(=)，直接初始化则是把初始化式放在括号中

int ival(8);
int ival = 8;


在c++中理解"初始化不是赋值"是必要的。初始化指创建变量并给它赋初始值，
而赋值则是擦除对象的当前值并用新值代替


使用多个初始化式


初始化内置类型的对象只有一个方法：提供一个值，并且把这个值复制到新定义的对象中。对内置
类型来说，复制初始化和直接初始化几乎没有差别


对类类型的对象来说，有些初始化仅能直接初始化完成。要想理解其中缘由，
需要初步了解类是如何控制初始化的

每个类都可能会定义一个或几个特殊的成员函数来告诉我们如何初始化类类型的变量。

定义如何进行初始化的成员函数称为构造函数。

和其他函数一样，构造函数能够接受多个参数。一个类可以定义几个构造函数，
每个构造函数必须接受不同数目或不同类型的参数

string类型在标准库中定义，用于存储不同长度的字符串。使用string时必须包含string头文件。
和IO类型一样，string定义在std命名空间中


string类定义了几个构造函数，使得我们可以用不同的方式初始化string对象。

其中一种初始化string对象的方式是作为字符串字面值的副本



#include<string>

std:: string titleA= "C++~";
std:: string titleB("C~~");


两种初始化方式都可以使用。两种定义都创建了一个string对象，其初始值都是指定的
字符串字面值的副本


也可以通过一个计数器和一个字符初始化string对象。这样创建的对象包含重复多次的指定字符，
重复次数由计数器指定：

std:: tring all_nines(10,'9');


初始化 all_nines的唯一方法是直接初始化。有多个初始化式时不能使用复制初始化


初始化多个变量


当一个定义中定义了两个以上变量的时候，每个变量都可能有自己的初始化式。对象的名字立即
变成可见，所以可以用同一个定义中前面已经定义变量的值初始化后面的变量。

已初始化变量和未初始化变量可以在同一个定义中定义。两种形式的初始化文法可以相互混合。

#include <string>


double salary = 99.00, wage(salary+0.0.1);
    int interval,
    month = 8,day=7 , year=1999;
    std:: string title("cc"),
    p = "a";


对象可以用任意复杂的表达式(包括函数的返回值)来初始化


2.3.4 变量初始化规则

当定义没有初始化式的变量时，系统有时候会帮我们初始化变量。这是，系统提供什么样的值
取决于变量的类型，也取决于变量定义的位置

内置类型变量的初始化


内置类型变量是否自动初始化取决于变量定义的位置。在函数体外定义的变量都初始化成0，
在函数体里定义的内置类型变量不进行自动初始化。

除了用作赋值操作符的左操作数，未初始化变量用左任何其他用途都是没有定义的。
未初始化变量引起的错误难于发现。永远不要依赖未定义行为


警告：未初始化的变量引起运行问题

建议每个内置类型的对象都要初始化

类类型变量的初始化

每个类都定义了该类型的对象可以怎样初始化。类通过定义一个或多个构造函数来控制
类对象的初始化。

例如， string类至少提供了两个构造函数，其中一个允许我们通过字符串字面值初始化string对象，
另一个允许我们通过字符和计数器初始化string对象



如果定义某个类的变量时没有提供初始化式，这个类也可以定义初始化时的操作。它是通过
定义一个特殊的构造函数即默认构造函数来实现的。

这个构造函数之所以被称作默认构造函数，是因为它是"默认"运行的。如果没有提供初始化式，
那么就会使用默认构造函数。

不管变量在哪里定义，默认构造函数都会被使用。


大多数类都提供了默认构造函数。如果类具有默认构造函数，那么就可以在定义该类的变量
时不用显式地初始化变量。例如，string类定义了默认构造函数来初始化string变量为空字符串，
即没有字符的字符串

std:: string empty;


有些类类型没有默认构造函数。对于这些类型来说，每个定义都必须提供显式的初始化式。
没有初始值是根本不可能定义这种类型的变量的

2.3.5  声明和定义

c++程序通常由许多文件组成，为了让多个文件访问相同的变量，c++区分了声明和定义


变量的定义用于为变量分配存储空间，还可以为变量指定初始值。在一个程序中，变量有
且仅有一个定义


声明用于向程序表明变量的类型和名字。定义也是声明：当定义变量时我们声明了它的类型和名字。

可以通过实用extern关键字声明变量名而不定义它。

不定义变量的声明包括对象名，对象类型和对象类型前的关键字extern:

extern int i;
int i;


extern声明不是定义，也不分配存储空间。事实上，它只是说明变量定义在程序的其他地方。程序
中变量可以声明多次，但只能定义一次。。


只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。初始化式必须要有
存储空间来进行初始化。如果声明有初始化式，那么它可被当做定义，即使声明标记为extern:

extern double pi =3.1416;

虽然使用了extern，但是这条语句还是定义了pi，分配并初始化了存储空间。

只有当extern声明位于函数外部时，才可以有初始化式。


因为已初始化的extern声明被当做是定义，所以该变量任何随后的定义都是错误的


在c++语言中，变量必须且仅能定义一次，而且在使用变量之前必须定义或声明变量

任何在多个文件中使用的变量都需要有与定义分离的声明。在这种情况下，一个文件含有变量的定义，
使用该变量的其他文件则包含该变量的声明(而不是定义)


2.3.6  名字的作用域


c++程序中，每个名字都与位于的实体(比如变量，函数和类型等)相关联


用来区分名字的意义的上下文称为作用域。作用域是程序的一段区域。一个名字可以和不同
作用域中的不同实体相关联

c++语言中，大多数作用与是用花括号来界定的。一般来说，名字从其声明点开始知道其声明所在的作用域结束
处都是可见


这个程序定义了三个名字，实用两个标准库的名字。程序定义了一个名为main的函数，以及两个名为
sum和val的变量。名字main定义在所有花括号之外，在整个程序都可见。

定义在所有函数外部的名字具有全局作用域，可以在程序中的任何地方访问

名字sum定义在main函数的作用域中，在整个main函数中都可以访问，但在main函数外则不能

变量sum有局部作用域。名字val，它定义在for语句的作用域中，只能在for语句中使用，
而不能用在main函数的其他地方。它具有语句作用域


c++中作用域可嵌套


定义在全局作用域中的名字可以在局部作用域中使用，定义在全局作用域中的名字和定义在函数的
局部作用域中的名字可以在语句作用域中使用，等等。
名字还可以在内部作用域中重新定义。理解和名字相关联的实体需要明白定义名字的作用域
这个程序中定义了三个变量：string类型的全局变量s1,string类型的局部变量 s2 和int类型的局部变量s1


局部变量s1的定义屏蔽了全局变量s1


变量从声明开始才可见，因此执行第一次输出时局部变量s1不可见，输出表达式中的s1是全局变量s1,输出"hello word"  .

第二条输出语句跟在s1的局部定义后，现在局部变量s1在作用域中。

第二条输出语句使用的是局部变量s1而不是全局变量s1, 

注意，在函数内定义一个与函数可能会用到的全局变量同名的局部变量总是不好。
局部变量最好使用不同的名字


2.3.7  在变量使用处定义变量

一般来说，变量的定义或声明可以放在程序中能摆放语句的任何位置。

变量在使用前必须先声明或定义。


通常把一个对象定义在它首次使用的地方是一个很好方法


在对象第一次被使用的地方定义对象可以提高程序的可读性。
读者不需要返回到代码段的开始位置去寻找某一特殊变量的定义，而且，在此处定义变量，更容易给它
赋予有意义的初始值


放置声明的一个约束是，变量只在从其定义处开始到该声明所在的作用域的结束处才可以访问。必须在使用
该变了呢的最外层作用域里面或之前定义变量。



2.4  const限定符


定义const对象

定义一个变量代表某一常数的方法仍然有一个严重的问题。即bufSize是可以被修改的。
bufSize可能被有意或无意地修改。

const限定符提供另一个解决方法，它吧一个对象转换成一个常量


const int bufSize = 512;


定义bufSize为常量病初始化为512.变量bufSize仍然是一个左值，但是现在这个左值是不可修改的。

任何修改bufSize的尝试都会导致编译错误




因为常量在定以后就不能被修改，所以定义时必须初始化：



const 对象默认为文件的局部变量


在全局作用域里定义非const变量时，它在整个程序中都可以访问。我们可以把一个非const变更
定义在一个文件中，假设已经做了合适的声明，就可以在另外的文件中使用这个变量：

与其他变量不同，除非特别说明，在全局作用域声明的const变量是定义该对象的文件的局部变量，
此变量只存在那个文件中，不能被其他文件访问

通过指定const变更为extern，就可以在整个程序中访问const对象



file_1.cc通过函数fcn的返回值来定义和初始化bufSize.而bufSize定义为extern,
也意味着bufSize可以在其他的文件中功能使用。

file_2.cc 中extern的声明同样是 extern:这种开那些，extern标志着bufSize是一个声明，所以
没有初始化式。


为何const对象局部与文件创建

非const变量默认为extern。要使const变量能够在其他的文件中访问，
必须地指定它为extern



2.5  引用


